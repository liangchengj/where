<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>PDF Writer, Job 2</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .p, p {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; margin:0pt; }
 h1 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s2 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s3 { color: #1A1A1A; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 12pt; }
 h2 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 .s4 {  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s5 { color: #1A1A1A; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s6 {  font-family:"Courier New", monospace; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .h4, h4 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s7 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 4pt; }
 .s8 {  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s9 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .h3, h3 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 .s10 {  font-family:"Courier New", monospace; font-style: italic; font-weight: normal; text-decoration: none; font-size: 5.5pt; vertical-align: -1pt; }
 .s11 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; vertical-align: 1pt; }
 .s12 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s13 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; vertical-align: 1pt; }
 .s14 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 4pt; }
 .s15 {  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 1pt; }
 .s16 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s17 { color: #1A1A1A; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10pt; }
 .s18 { color: #1A1A1A; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s19 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -1pt; }
 .s20 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s21 {  font-family:"Times New Roman", serif; font-style: italic; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s22 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s23 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s24 {  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10pt; vertical-align: 1pt; }
 .s25 {  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10pt; }
 .s27 {  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -5pt; }
 .s28 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; vertical-align: -1pt; }
 .s29 {  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 3pt; }
 .s31 {  font-family:"Courier New", monospace; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 1; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt;counter-reset: c2 1; }
 #l2> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l3 {padding-left: 0pt;counter-reset: c3 1; }
 #l3> li>*:first-child:before {counter-increment: c3; content: counter(c1, decimal)"."counter(c2, decimal)"."counter(c3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: c3 0;  }
 li {display: block; }
 #l4 {padding-left: 0pt;counter-reset: d1 2; }
 #l4> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l4> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l5 {padding-left: 0pt;counter-reset: d2 1; }
 #l5> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 li {display: block; }
 #l6 {padding-left: 0pt;counter-reset: e1 3; }
 #l6> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l6> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l7 {padding-left: 0pt;counter-reset: e2 1; }
 #l7> li>*:first-child:before {counter-increment: e2; content: counter(e1, decimal)"."counter(e2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 li {display: block; }
 #l8 {padding-left: 0pt;counter-reset: f1 4; }
 #l8> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l8> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l9 {padding-left: 0pt;counter-reset: f2 1; }
 #l9> li>*:first-child:before {counter-increment: f2; content: counter(f1, decimal)"."counter(f2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: f2 0;  }
 #l10 {padding-left: 0pt;counter-reset: f3 1; }
 #l10> li>*:first-child:before {counter-increment: f3; content: counter(f1, decimal)"."counter(f2, decimal)"."counter(f3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: f3 0;  }
 li {display: block; }
 #l11 {padding-left: 0pt;counter-reset: g1 5; }
 #l11> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l11> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 #l12 {padding-left: 0pt;counter-reset: g2 1; }
 #l12> li>*:first-child:before {counter-increment: g2; content: counter(g1, decimal)"."counter(g2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: g2 0;  }
 li {display: block; }
 #l13 {padding-left: 0pt;counter-reset: h1 6; }
 #l13> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l13> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l14 {padding-left: 0pt;counter-reset: h2 1; }
 #l14> li>*:first-child:before {counter-increment: h2; content: counter(h1, decimal)"."counter(h2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l14> li:first-child>*:first-child:before {counter-increment: h2 0;  }
 li {display: block; }
 #l15 {padding-left: 0pt;counter-reset: i1 7; }
 #l15> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l15> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l16 {padding-left: 0pt;counter-reset: i2 1; }
 #l16> li>*:first-child:before {counter-increment: i2; content: counter(i1, decimal)"."counter(i2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l16> li:first-child>*:first-child:before {counter-increment: i2 0;  }
 #l17 {padding-left: 0pt;counter-reset: i3 1; }
 #l17> li>*:first-child:before {counter-increment: i3; content: counter(i1, decimal)"."counter(i2, decimal)"."counter(i3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l17> li:first-child>*:first-child:before {counter-increment: i3 0;  }
 li {display: block; }
 #l18 {padding-left: 0pt;counter-reset: j1 8; }
 #l18> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l18> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l19 {padding-left: 0pt;counter-reset: j2 1; }
 #l19> li>*:first-child:before {counter-increment: j2; content: counter(j1, decimal)"."counter(j2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: j2 0;  }
 li {display: block; }
 #l20 {padding-left: 0pt;counter-reset: k1 1; }
 #l20> li>*:first-child:before {counter-increment: k1; content: counter(k1, upper-latin)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l20> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l21 {padding-left: 0pt;counter-reset: k2 1; }
 #l21> li>*:first-child:before {counter-increment: k2; content: counter(k1, upper-latin)"."counter(k2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: k2 0;  }
 #l22 {padding-left: 0pt;counter-reset: k3 1; }
 #l22> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l23 {padding-left: 0pt;counter-reset: k3 1; }
 #l23> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l23> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l24 {padding-left: 0pt;counter-reset: k3 1; }
 #l24> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l24> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l25 {padding-left: 0pt;counter-reset: k3 1; }
 #l25> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l25> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l26 {padding-left: 0pt;counter-reset: k3 1; }
 #l26> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l26> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l27 {padding-left: 0pt;counter-reset: k3 1; }
 #l27> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l27> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l28 {padding-left: 0pt;counter-reset: k3 1; }
 #l28> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l28> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l29 {padding-left: 0pt;counter-reset: k3 1; }
 #l29> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l29> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 #l30 {padding-left: 0pt;counter-reset: k3 1; }
 #l30> li>*:first-child:before {counter-increment: k3; content: counter(k1, upper-latin)"."counter(k2, decimal)"."counter(k3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l30> li:first-child>*:first-child:before {counter-increment: k3 0;  }
 li {display: block; }
 #l31 {padding-left: 0pt;counter-reset: l1 2; }
 #l31> li>*:first-child:before {counter-increment: l1; content: counter(l1, upper-latin)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l31> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 #l32 {padding-left: 0pt;counter-reset: l2 1; }
 #l32> li>*:first-child:before {counter-increment: l2; content: counter(l1, upper-latin)"."counter(l2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l32> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l33 {padding-left: 0pt;counter-reset: l3 1; }
 #l33> li>*:first-child:before {counter-increment: l3; content: counter(l1, upper-latin)"."counter(l2, decimal)"."counter(l3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l33> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 li {display: block; }
 #l34 {padding-left: 0pt;counter-reset: m1 1; }
 #l34> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l34> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l35 {padding-left: 0pt;counter-reset: m2 1; }
 #l35> li>*:first-child:before {counter-increment: m2; content: counter(m1, decimal)"."counter(m2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l35> li:first-child>*:first-child:before {counter-increment: m2 0;  }
 #l36 {padding-left: 0pt;counter-reset: m3 1; }
 #l36> li>*:first-child:before {counter-increment: m3; content: counter(m1, decimal)"."counter(m2, decimal)"."counter(m3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12.5pt; }
 #l36> li:first-child>*:first-child:before {counter-increment: m3 0;  }
 li {display: block; }
 #l37 {padding-left: 0pt;counter-reset: n1 2; }
 #l37> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l37> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l38 {padding-left: 0pt;counter-reset: n2 1; }
 #l38> li>*:first-child:before {counter-increment: n2; content: counter(n1, decimal)"."counter(n2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l38> li:first-child>*:first-child:before {counter-increment: n2 0;  }
 #l39 {padding-left: 0pt; }
 #l39> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l40 {padding-left: 0pt;counter-reset: o1 3; }
 #l40> li>*:first-child:before {counter-increment: o1; content: counter(o1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l40> li:first-child>*:first-child:before {counter-increment: o1 0;  }
 #l41 {padding-left: 0pt;counter-reset: o2 1; }
 #l41> li>*:first-child:before {counter-increment: o2; content: counter(o1, decimal)"."counter(o2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l41> li:first-child>*:first-child:before {counter-increment: o2 0;  }
 li {display: block; }
 #l42 {padding-left: 0pt;counter-reset: p1 4; }
 #l42> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l42> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l43 {padding-left: 0pt;counter-reset: p2 1; }
 #l43> li>*:first-child:before {counter-increment: p2; content: counter(p1, decimal)"."counter(p2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l43> li:first-child>*:first-child:before {counter-increment: p2 0;  }
 #l44 {padding-left: 0pt; }
 #l44> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l45 {padding-left: 0pt;counter-reset: q1 4; }
 #l45> li>*:first-child:before {counter-increment: q1; content: counter(q1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l45> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 #l46 {padding-left: 0pt;counter-reset: q2 11; }
 #l46> li>*:first-child:before {counter-increment: q2; content: counter(q1, decimal)"."counter(q2, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l46> li:first-child>*:first-child:before {counter-increment: q2 0;  }
 #l47 {padding-left: 0pt;counter-reset: q3 1; }
 #l47> li>*:first-child:before {counter-increment: q3; content: counter(q1, decimal)"."counter(q2, decimal)"."counter(q3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l47> li:first-child>*:first-child:before {counter-increment: q3 0;  }
 li {display: block; }
 #l48 {padding-left: 0pt;counter-reset: r1 5; }
 #l48> li>*:first-child:before {counter-increment: r1; content: counter(r1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l48> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 #l49 {padding-left: 0pt;counter-reset: r2 1; }
 #l49> li>*:first-child:before {counter-increment: r2; content: counter(r1, decimal)"."counter(r2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l49> li:first-child>*:first-child:before {counter-increment: r2 0;  }
 li {display: block; }
 #l50 {padding-left: 0pt;counter-reset: s1 6; }
 #l50> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l50> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l51 {padding-left: 0pt;counter-reset: s2 1; }
 #l51> li>*:first-child:before {counter-increment: s2; content: counter(s1, decimal)"."counter(s2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l51> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l52 {padding-left: 0pt; }
 #l52> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l53 {padding-left: 0pt;counter-reset: t1 7; }
 #l53> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l53> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 #l54 {padding-left: 0pt;counter-reset: t2 1; }
 #l54> li>*:first-child:before {counter-increment: t2; content: counter(t1, decimal)"."counter(t2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l54> li:first-child>*:first-child:before {counter-increment: t2 0;  }
 #l55 {padding-left: 0pt; }
 #l55> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l56 {padding-left: 0pt; }
 #l56> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l57 {padding-left: 0pt;counter-reset: u1 7; }
 #l57> li>*:first-child:before {counter-increment: u1; content: counter(u1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l57> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 #l58 {padding-left: 0pt;counter-reset: u2 5; }
 #l58> li>*:first-child:before {counter-increment: u2; content: counter(u1, decimal)"."counter(u2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l58> li:first-child>*:first-child:before {counter-increment: u2 0;  }
 #l59 {padding-left: 0pt;counter-reset: u3 1; }
 #l59> li>*:first-child:before {counter-increment: u3; content: counter(u1, decimal)"."counter(u2, decimal)"."counter(u3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l59> li:first-child>*:first-child:before {counter-increment: u3 0;  }
 li {display: block; }
 #l60 {padding-left: 0pt;counter-reset: v1 8; }
 #l60> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l60> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l61 {padding-left: 0pt;counter-reset: v2 1; }
 #l61> li>*:first-child:before {counter-increment: v2; content: counter(v1, decimal)"."counter(v2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l61> li:first-child>*:first-child:before {counter-increment: v2 0;  }
 li {display: block; }
 #l62 {padding-left: 0pt;counter-reset: w1 1; }
 #l62> li>*:first-child:before {counter-increment: w1; content: counter(w1, upper-latin)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l62> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 #l63 {padding-left: 0pt;counter-reset: w2 1; }
 #l63> li>*:first-child:before {counter-increment: w2; content: counter(w1, upper-latin)"."counter(w2, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l63> li:first-child>*:first-child:before {counter-increment: w2 0;  }
 #l64 {padding-left: 0pt;counter-reset: w3 1; }
 #l64> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l64> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l65 {padding-left: 0pt;counter-reset: w4 1; }
 #l65> li>*:first-child:before {counter-increment: w4; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)"."counter(w4, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l65> li:first-child>*:first-child:before {counter-increment: w4 0;  }
 #l66 {padding-left: 0pt;counter-reset: w3 1; }
 #l66> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l66> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l67 {padding-left: 0pt;counter-reset: w3 1; }
 #l67> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l67> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l68 {padding-left: 0pt; }
 #l68> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l69 {padding-left: 0pt;counter-reset: w3 1; }
 #l69> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l69> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l70 {padding-left: 0pt;counter-reset: w4 1; }
 #l70> li>*:first-child:before {counter-increment: w4; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)"."counter(w4, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l70> li:first-child>*:first-child:before {counter-increment: w4 0;  }
 #l71 {padding-left: 0pt;counter-reset: w4 1; }
 #l71> li>*:first-child:before {counter-increment: w4; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)"."counter(w4, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l71> li:first-child>*:first-child:before {counter-increment: w4 0;  }
 #l72 {padding-left: 0pt;counter-reset: w3 1; }
 #l72> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l72> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l73 {padding-left: 0pt; }
 #l73> li>*:first-child:before {content: "* ";  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 1pt; }
 #l74 {padding-left: 0pt;counter-reset: w4 1; }
 #l74> li>*:first-child:before {counter-increment: w4; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)"."counter(w4, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l74> li:first-child>*:first-child:before {counter-increment: w4 0;  }
 #l75 {padding-left: 0pt;counter-reset: z1 1; }
 #l75> li>*:first-child:before {counter-increment: z1; content: counter(z1, upper-latin)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l75> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 #l76 {padding-left: 0pt;counter-reset: z2 8; }
 #l76> li>*:first-child:before {counter-increment: z2; content: counter(z1, upper-latin)"."counter(z2, decimal)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l76> li:first-child>*:first-child:before {counter-increment: z2 0;  }
 #l77 {padding-left: 0pt;counter-reset: z3 8; }
 #l77> li>*:first-child:before {counter-increment: z3; content: counter(z1, upper-latin)"."counter(z2, decimal)"."counter(z3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l77> li:first-child>*:first-child:before {counter-increment: z3 0;  }
 #l78 {padding-left: 0pt;counter-reset: w3 1; }
 #l78> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l78> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l79 {padding-left: 0pt;counter-reset: w3 1; }
 #l79> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l79> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l80 {padding-left: 0pt;counter-reset: w3 1; }
 #l80> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l80> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 #l81 {padding-left: 0pt;counter-reset: c1 1; }
 #l81> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l81> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l82 {padding-left: 0pt;counter-reset: w3 1; }
 #l82> li>*:first-child:before {counter-increment: w3; content: counter(w1, upper-latin)"."counter(w2, decimal)"."counter(w3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l82> li:first-child>*:first-child:before {counter-increment: w3 0;  }
 li {display: block; }
 #l83 {padding-left: 0pt; }
 #l83> li>*:first-child:before {content: "* ";  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 1pt; }
 li {display: block; }
 #l84 {padding-left: 0pt;counter-reset: e1 2; }
 #l84> li>*:first-child:before {counter-increment: e1; content: counter(e1, upper-latin)" ";  font-style: normal; font-weight: normal; text-decoration: none; }
 #l84> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l85 {padding-left: 0pt;counter-reset: e2 1; }
 #l85> li>*:first-child:before {counter-increment: e2; content: counter(e1, upper-latin)"."counter(e2, decimal)" ";  font-style: normal; font-weight: bold; text-decoration: none; }
 #l85> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 #l86 {padding-left: 0pt;counter-reset: e3 1; }
 #l86> li>*:first-child:before {counter-increment: e3; content: counter(e1, upper-latin)"."counter(e2, decimal)"."counter(e3, decimal)" ";  font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 #l86> li:first-child>*:first-child:before {counter-increment: e3 0;  }
 #l87 {padding-left: 0pt; }
 #l87> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l88 {padding-left: 0pt; }
 #l88> li>*:first-child:before {content: "o ";  font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l89 {padding-left: 0pt; }
 #l89> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l90 {padding-left: 0pt; }
 #l90> li>*:first-child:before {content: "• ";  font-family:Symbol; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body>

<span>![image](The C Programming Language英文版 - 副本/Image_001.gif)</span>

Preface 6

Preface to the first edition 8

Chapter 1 - A Tutorial Introduction 9

Chapter 2 - Types, Operators and Expressions 35

Chapter 3 - Control Flow 50

Chapter 4 - Functions and Program Structure 59

Chapter 5 - Pointers and Arrays 78

Chapter 6 - Structures 105

Chapter 7 - Input and Output 124

Chapter 8 - The UNIX System Interface 138

Appendix A - Reference Manual 154

Appendix B - Standard Library 200

Appendix C - Summary of Changes 215

# Preface

The computing world has undergone a revolution since the publication of _The C Programming Language _in 1978. Big computers are much bigger, and personal computers have capabilities that rival mainframes of a decade ago. During this time, C has changed too, although only modestly, and it has spread far beyond its origins as the language of the UNIX operating system.

The growing popularity of C, the changes in the language over the years, and the creation of compilers by groups not involved in its design, combined to demonstrate a need for a more precise and more contemporary definition of the language than the first edition of this book provided. In 1983, the American National Standards Institute (ANSI) established a committee whose goal was to produce ``an unambiguous and machine-independent definition of the language C&#39;&#39;, while still retaining its spirit. The result is the ANSI standard for C.

The standard formalizes constructions that were hinted but not described in the first edition, particularly structure assignment and enumerations. It provides a new form of function declaration that permits cross-checking of definition with use. It specifies a standard library, with an extensive set of functions for performing input and output, memory management, string manipulation, and similar tasks. It makes precise the behavior of features that were not spelled out in the original definition, and at the same time states explicitly which aspects of the language remain machine-dependent.

This Second Edition of _The C Programming Language _describes C as defined by the ANSI standard. Although we have noted the places where the language has evolved, we have chosen to write exclusively in the new form. For the most part, this makes no significant difference; the most visible change is the new form of function declaration and definition. Modern compilers already support most features of the standard.

We have tried to retain the brevity of the first edition. C is not a big language, and it is not well served by a big book. We have improved the exposition of critical features, such as pointers, that are central to C programming. We have refined the original examples, and have added new examples in several chapters. For instance, the treatment of complicated declarations is augmented by programs that convert declarations into words and vice versa. As before, all examples have been tested directly from the text, which is in machine-readable form.

Appendix A, the reference manual, is not the standard, but our attempt to convey the essentials of the standard in a smaller space. It is meant for easy comprehension by programmers, but not as a definition for compiler writers -- that role properly belongs to the standard itself. Appendix B is a summary of the facilities of the standard library. It too is meant for reference by programmers, not implementers. Appendix C is a concise summary of the changes from the original version.

As we said in the preface to the first edition, C ``wears well as one&#39;s experience with it grows&#39;&#39;. With a decade more experience, we still feel that way. We hope that this book will help you learn C and use it well.

We are deeply indebted to friends who helped us to produce this second edition. Jon Bently, Doug Gwyn, Doug McIlroy, Peter Nelson, and Rob Pike gave us perceptive comments on almost every page of draft manuscripts. We are grateful for careful reading by Al Aho, Dennis Allison, Joe Campbell, G.R. Emlin, Karen Fortgang, Allen Holub, Andrew Hume, Dave Kristol, John Linderman, Dave Prosser, Gene Spafford, and Chris van Wyk. We also received helpful suggestions from Bill Cheswick, Mark Kernighan, Andy Koenig, Robin Lake, Tom London, Jim Reeds, Clovis Tondo, and Peter Weinberger. Dave Prosser answered

many detailed questions about the ANSI standard. We used Bjarne Stroustrup&#39;s C++ translator extensively for local testing of our programs, and Dave Kristol provided us with an ANSI C compiler for final testing. Rich Drechsler helped greatly with typesetting.

Our sincere thanks to all.

Brian W. Kernighan Dennis M. Ritchie

# Preface to the first edition

C is a general-purpose programming language with features economy of expression, modern flow control and data structures, and a rich set of operators. C is not a ``very high level&#39;&#39; language, nor a ``big&#39;&#39; one, and is not specialized to any particular area of application. But its absence of restrictions and its generality make it more convenient and effective for many tasks than supposedly more powerful languages.

C was originally designed for and implemented on the UNIX operating system on the DEC PDP-11, by Dennis Ritchie. The operating system, the C compiler, and essentially all UNIX applications programs (including all of the software used to prepare this book) are written in

C. Production compilers also exist for several other machines, including the IBM System/370, the Honeywell 6000, and the Interdata 8/32. C is not tied to any particular hardware or system, however, and it is easy to write programs that will run without change on any machine that supports C.

This book is meant to help the reader learn how to program in C. It contains a tutorial introduction to get new users started as soon as possible, separate chapters on each major feature, and a reference manual. Most of the treatment is based on reading, writing and revising examples, rather than on mere statements of rules. For the most part, the examples are complete, real programs rather than isolated fragments. All examples have been tested directly from the text, which is in machine-readable form. Besides showing how to make effective use of the language, we have also tried where possible to illustrate useful algorithms and principles of good style and sound design.

The book is not an introductory programming manual; it assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. Nonetheless, a novice programmer should be able to read along and pick up the language, although access to more knowledgeable colleague will help.

In our experience, C has proven to be a pleasant, expressive and versatile language for a wide variety of programs. It is easy to learn, and it wears well as on&#39;s experience with it grows. We hope that this book will help you to use it well.

The thoughtful criticisms and suggestions of many friends and colleagues have added greatly to this book and to our pleasure in writing it. In particular, Mike Bianchi, Jim Blue, Stu Feldman, Doug McIlroy Bill Roome, Bob Rosin and Larry Rosler all read multiple volumes with care. We are also indebted to Al Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie Haley, Marion Harris, Rick Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha, Peter Nelson, Elliot Pinson, Bill Plauger, Jerry Spivack, Ken Thompson, and Peter Weinberger for helpful comments at various stages, and to Mile Lesk and Joe Ossanna for invaluable assistance with typesetting.

Brian W. Kernighan Dennis M. Ritchie

# Chapter 1 - A Tutorial Introduction

Let us begin with a quick introduction in C. Our aim is to show the essential elements of the language in real programs, but without getting bogged down in details, rules, and exceptions. At this point, we are not trying to be complete or even precise (save that the examples are meant to be correct). We want to get you as quickly as possible to the point where you can write useful programs, and to do that we have to concentrate on the basics: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output. We are intentionally leaving out of this chapter features of C that are important for writing bigger programs. These include pointers, structures, most of C&#39;s rich set of operators, several control-flow statements, and the standard library.

This approach and its drawbacks. Most notable is that the complete story on any particular feature is not found here, and the tutorial, by being brief, may also be misleading. And because the examples do not use the full power of C, they are not as concise and elegant as they might be. We have tried to minimize these effects, but be warned. Another drawback is that later chapters will necessarily repeat some of this chapter. We hope that the repetition will help you more than it annoys.

In any case, experienced programmers should be able to extrapolate from the material in this chapter to their own programming needs. Beginners should supplement it by writing small, similar programs of their own. Both groups can use it as a framework on which to hang the more detailed descriptions that begin in <span class="s3">Chapter 2</span>.

The variables in <span class="s4">main</span>, such as <span class="s4">line</span>, <span class="s4">longest</span>, etc., are private or local to <span class="s4">main</span>. Because they are declared within <span class="s4">main</span>, no other function can have direct access to them. The same is true of the variables in other functions; for example, the variable <span class="s4">i </span>in <span class="s4">getline </span>is unrelated to the <span class="s4">i </span>in copy. Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited. This is why such variables are usually known as _automatic _variables, following terminology in other languages. We will use the term automatic henceforth to refer to these local variables. (<span class="s3">Chapter 4</span> discusses the <span class="s4">static </span>storage class, in which local variables do retain their values between calls.)

Because automatic variables come and go with function invocation, they do not retain their values from one call to the next, and must be explicitly set upon each entry. If they are not set, they will contain garbage.

As an alternative to automatic variables, it is possible to define variables that are _external _to all functions, that is, variables that can be accessed by name by any function. (This mechanism is rather like Fortran COMMON or Pascal variables declared in the outermost block.) Because external variables are globally accessible, they can be used instead of

argument lists to communicate data between functions. Furthermore, because external variables remain in existence permanently, rather than appearing and disappearing as functions are called and exited, they retain their values even after the functions that set them have returned.

An external variable must be _defined_, exactly once, outside of any function; this sets aside storage for it. The variable must also be _declared _in each function that wants to access it; this states the type of the variable. The declaration may be an explicit <span class="s4">extern </span>statement or may be implicit from context. To make the discussion concrete, let us rewrite the longest-line program with <span class="s4">line</span>, <span class="s4">longest</span>, and <span class="s4">max </span>as external variables. This requires changing the calls, declarations, and bodies of all three functions.

#include &lt;stdio.h&gt;

#define MAXLINE 1000 /* maximum input line size */

int max; /* maximum length seen so far */ char line[MAXLINE]; /* current input line */

char longest[MAXLINE]; /* longest line saved here */

int getline(void); void copy(void);

/* print longest input line; specialized version */ main()

{

int len; extern int max;

extern char longest[];

max = 0;

while ((len = getline()) &gt; 0) if (len &gt; max) {

max = len; copy();

}

if (max &gt; 0) /* there was a line */ printf(&quot;%s&quot;, longest);

return 0;

}

/* getline: specialized version */ int getline(void)

{

int c, i;

extern char line[];

for (i = 0; i &lt; MAXLINE - 1

&amp;&amp; (c=getchar)) != EOF &amp;&amp; c != &#39;\n&#39;; ++i) line[i] = c;

if (c == &#39;\n&#39;) { line[i] = c;

++i;

}

line[i] = &#39;\0&#39;; return i;

}

/* copy: specialized version */ void copy(void)

{

int i;

extern char line[], longest[];

i = 0;

while ((longest[i] = line[i]) != &#39;\0&#39;)

++i;

}

The external variables in <span class="s4">main</span>, <span class="s4">getline </span>and <span class="s4">copy </span>are defined by the first lines of the example above, which state their type and cause storage to be allocated for them. Syntactically, external definitions are just like definitions of local variables, but since they occur outside of functions, the variables are external. Before a function can use an external variable, the name of the variable must be made known to the function; the declaration is the same as before except for the added keyword <span class="s4">extern</span>.

In certain circumstances, the <span class="s4">extern </span>declaration can be omitted. If the definition of the external variable occurs in the source file before its use in a particular function, then there is no need for an <span class="s4">extern </span>declaration in the function. The <span class="s4">extern </span>declarations in <span class="s4">main</span>, <span class="s4">getline </span>and <span class="s4">copy </span>are thus redundant. In fact, common practice is to place definitions of all external variables at the beginning of the source file, and then omit all extern declarations.

If the program is in several source files, and a variable is defined in _file1 _and used in _file2 _and _file3_, then <span class="s4">extern </span>declarations are needed in _file2 _and _file3 _to connect the occurrences of the variable. The usual practice is to collect <span class="s4">extern </span>declarations of variables and functions in a separate file, historically called a _header_, that is included by <span class="s4">#include </span>at the front of each source file. The suffix <span class="s4">.h </span>is conventional for header names. The functions of the standard library, for example, are declared in headers like <span class="s4">&lt;stdio.h&gt;</span>. This topic is discussed at length in <span class="s3">Chapter 4</span>, and the library itself in <span class="s3">Chapter 7</span> and <span class="s3">Appendix B</span>.

Since the specialized versions of <span class="s4">getline </span>and <span class="s4">copy </span>have no arguments, logic would suggest that their prototypes at the beginning of the file should be <span class="s4">getline() </span>and <span class="s4">copy()</span>. But for compatibility with older C programs the standard takes an empty list as an old-style declaration, and turns off all argument list checking; the word <span class="s4">void </span>must be used for an explicitly empty list. We will discuss this further in <span class="s3">Chapter 4</span>.

You should note that we are using the words _definition _and _declaration _carefully when we refer to external variables in this section.``Definition&#39;&#39; refers to the place where the variable is created or assigned storage; ``declaration&#39;&#39; refers to places where the nature of the variable is stated but no storage is allocated.

By the way, there is a tendency to make everything in sight an <span class="s4">extern </span>variable because it appears to simplify communications - argument lists are short and variables are always there when you want them. But external variables are always there even when you don&#39;t want them. Relying too heavily on external variables is fraught with peril since it leads to programs whose data connections are not all obvious - variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify. The second version of the longest- line program is inferior to the first, partly for these reasons, and partly because it destroys the generality of two useful functions by writing into them the names of the variables they manipulate.

At this point we have covered what might be called the conventional core of C. With this handful of building blocks, it&#39;s possible to write useful programs of considerable size, and it would probably be a good idea if you paused long enough to do so. These exercises suggest programs of somewhat greater complexity than the ones earlier in this chapter.

**Exercise 1-20. **Write a program <span class="s4">detab </span>that replaces tabs in the input with the proper number of blanks to space to the next tab stop. Assume a fixed set of tab stops, say every _n _columns. Should _n _be a variable or a symbolic parameter?

**Exercise 1-21. **Write a program <span class="s4">entab </span>that replaces strings of blanks by the minimum number of tabs and blanks to achieve the same spacing. Use the same tab stops as for <span class="s4">detab</span>. When either a tab or a single blank would suffice to reach a tab stop, which should be given preference?

**Exercise 1-22. **Write a program to ``fold&#39;&#39; long input lines into two or more shorter lines after the last non-blank character that occurs before the _n_-th column of input. Make sure your program does something intelligent with very long lines, and if there are no blanks or tabs before the specified column.

#### Exercise 1-23. <span class="p">Write a program to remove all comments from a C program. Don&#39;t forget to handle quoted strings and character constants properly. C comments don&#39;t nest.</span>

#### Exercise 1-24. <span class="p">Write a program to check a C program for rudimentary syntax errors like unmatched parentheses, brackets and braces. Don&#39;t forget about quotes, both single and double, escape sequences, and comments. (This program is hard if you do it in full generality.)</span>

# Chapter 2 - Types, Operators and Expressions

Variables and constants are the basic data objects manipulated in a program. Declarations list the variables to be used, and state what type they have and perhaps what their initial values are. Operators specify what is to be done to them. Expressions combine variables and constants to produce new values. The type of an object determines the set of values it can have and what operations can be performed on it. These building blocks are the topics of this chapter.

The ANSI standard has made many small changes and additions to basic types and expressions. There are now <span class="s4">signed </span>and <span class="s4">unsigned </span>forms of all integer types, and notations for unsigned constants and hexadecimal character constants. Floating-point operations may be done in single precision; there is also a <span class="s4">long </span>double type for extended precision. String constants may be concatenated at compile  time. Enumerations have become part of the language, formalizing a feature of long standing. Objects may be declared <span class="s4">const</span>, which prevents them from being changed. The rules for automatic coercions among arithmetic types have been augmented to handle the richer set of types.

Table 2.1 summarizes the rules for precedence and associativity of all operators, including those that we have not yet discussed. Operators on the same line have the same precedence; rows are in order of decreasing precedence, so, for example, <span class="s4">*</span>, <span class="s4">/</span>, and <span class="s4">% </span>all have the same precedence, which is higher than that of binary <span class="s4">+ </span>and <span class="s4">-</span>. The ``operator&#39;&#39; <span class="s4">() </span>refers to function call. The operators <span class="s4">-&gt; </span>and <span class="s4">. </span>are used to access members of structures; they will be covered in <span class="s3">Chapter 6</span>, along with <span class="s4">sizeof </span>(size of an object). <span class="s3">Chapter 5</span> discusses <span class="s4">* </span>(indirection through a pointer) and <span class="s4">&amp; </span>(address of an object), and <span class="s3">Chapter 3</span> discusses the comma operator.
<table style="border-collapse:collapse;margin-left:96.585pt" cellspacing="0"><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

Operators
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

Associativity
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

() [] -&gt; .
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

<span class="s8">! ~ ++ -- + - * </span>(_type_) <span class="s8">sizeof</span>
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

right to left
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

* / %
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

+ -
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

&lt;&lt; &gt;&gt;
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

&lt; &lt;= &gt; &gt;=
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

== !=
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

&amp;
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

^
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

|
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

&amp;&amp;
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

||
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

?:
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

right to left
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:dashed;border-right-width:1pt;border-right-color:#7E7E7E">

right to left
</td></tr><tr style="height:16pt"><td style="width:203pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:dashed;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

,
</td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

left to right
</td></tr></table>

Unary &amp; +, -, and * have higher precedence than the binary forms.

Table 2.1: <span class="s2">Precedence and Associativity of Operators</span>

Note that the precedence of the bitwise operators <span class="s4">&amp;</span>, <span class="s4">^</span>, and <span class="s4">| </span>falls below <span class="s4">== </span>and <span class="s4">!=</span>. This implies that bit-testing expressions like

if ((x &amp; MASK) == 0) ...

must be fully parenthesized to give proper results.

C, like most languages, does not specify the order in which the operands of an operator are evaluated. (The exceptions are <span class="s4">&amp;&amp;</span>, <span class="s4">||</span>, <span class="s4">?:</span>, and `<span class="s4">,</span>&#39;.) For example, in a statement like

x = f() + g();

f <span class="p">may be evaluated before </span>g <span class="p">or vice versa; thus if either </span>f <span class="p">or </span>g <span class="p">alters a variable on which the other depends, </span>x <span class="p">can depend on the order of evaluation. Intermediate results can be stored in temporary variables to ensure a particular sequence.</span>

Similarly, the order in which function arguments are evaluated is not specified, so the statement

printf(&quot;%d %d\n&quot;, ++n, power(2, n)); /* WRONG */

can produce different results with different compilers, depending on whether <span class="s4">n </span>is incremented before <span class="s4">power </span>is called. The solution, of course, is to write

++n;

printf(&quot;%d %d\n&quot;, n, power(2, n));

Function calls, nested assignment statements, and increment and decrement operators cause

``side effects&#39;&#39; - some variable is changed as a by-product of the evaluation of an expression. In any expression involving side effects, there can be subtle dependencies on the order in which variables taking part in the expression are updated. One unhappy situation is typified by the statement

a[i] = i++;

The question is whether the subscript is the old value of <span class="s4">i </span>or the new. Compilers can interpret this in different ways, and generate different answers depending on their interpretation. The standard intentionally leaves most such matters unspecified. When side effects (assignment to variables) take place within an expression is left to the discretion of the compiler, since the best order depends strongly on machine architecture. (The standard does specify that all side effects on arguments take effect before a function is called, but that would not help in the call to <span class="s4">printf </span>above.)

The moral is that writing code that depends on order of evaluation is a bad programming practice in any language. Naturally, it is necessary to know what things to avoid, but if you don&#39;t know _how _they are done on various machines, you won&#39;t be tempted to take advantage of a particular implementation.

# Chapter 3 - Control Flow

The control-flow of a language specify the order in which computations are performed. We have already met the most common control-flow constructions in earlier examples; here we will complete the set, and be more precise about the ones discussed before.

C provides the infinitely-abusable <span class="s4">goto </span>statement, and labels to branch to. Formally, the <span class="s4">goto </span>statement is never necessary, and in practice it is almost always easy to write code without it. We have not used <span class="s4">goto </span>in this book.

Nevertheless, there are a few situations where <span class="s4">goto</span>s may find a place. The most common is to abandon processing in some deeply nested structure, such as breaking out of two or more loops at once. The <span class="s4">break </span>statement cannot be used directly since it only exits from the innermost loop. Thus:

for ( ... )

for ( ... ) {

...

if (disaster)

goto error;

}

...

error:

/* clean up the mess */

This organization is handy if the error-handling code is non-trivial, and if errors can occur in several places.

A label has the same form as a variable name, and is followed by a colon. It can be attached to any statement in the same function as the <span class="s4">goto</span>. The scope of a label is the entire function.

As another example, consider the problem of determining whether two arrays <span class="s4">a </span>and <span class="s4">b </span>have an element in common. One possibility is

for (i = 0; i &lt; n; i++) for (j = 0; j &lt; m; j++)

if (a[i] == b[j]) goto found;

/* didn&#39;t find any common element */

...

found:

/* got one: a[i] == b[j] */

...

Code involving a <span class="s4">goto </span>can always be written without one, though perhaps at the price of some repeated tests or an extra variable. For example, the array search becomes

found = 0;

for (i = 0; i &lt; n &amp;&amp; !found; i++) for (j = 0; j &lt; m &amp;&amp; !found; j++)

if (a[i] == b[j]) found = 1;

if (found)

/* got one: a[i-1] == b[j-1] */

...

else

/* didn&#39;t find any common element */

...

With a few exceptions like those cited here, code that relies on <span class="s4">goto </span>statements is generally harder to understand and to maintain than code without <span class="s4">goto</span>s. Although we are not dogmatic about the matter, it does seem that <span class="s4">goto </span>statements should be used rarely, if at all.

# Chapter 4 - Functions and Program Structure

Functions break large computing tasks into smaller ones, and enable people to build on what others have done instead of starting over from scratch. Appropriate functions hide details of operation from parts of the program that don&#39;t need to know about them, thus clarifying the whole, and easing the pain of making changes.

C has been designed to make functions efficient and easy to use; C programs generally consist of many small functions rather than a few big ones. A program may reside in one or more source files. Source files may be compiled separately and loaded together, along with previously compiled functions from libraries. We will not go into that process here, however, since the details vary from system to system.

Function declaration and definition is the area where the ANSI standard has made the most changes to C. As we saw first in <span class="s3">Chapter 1</span>, it is now possible to declare the type of arguments when a function is declared. The syntax of function declaration also changes, so that declarations and definitions match. This makes it possible for a compiler to detect many more errors than it could before. Furthermore, when arguments are properly declared, appropriate type coercions are performed automatically.

The standard clarifies the rules on the scope of names; in particular, it requires that there be only one definition of each external object. Initialization is more general: automatic arrays and structures may now be initialized.

The C preprocessor has also been enhanced. New preprocessor facilities include a more complete set of conditional compilation directives, a way to create quoted strings from macro arguments, and better control over the macro expansion process.

C provides certain language facilities by means of a preprocessor, which is conceptionally a separate first step in compilation. The two most frequently used features are <span class="s4">#include</span>, to

include the contents of a file during compilation, and <span class="s4">#define</span>, to replace a token by an arbitrary sequence of characters. Other features described in this section include conditional compilation and macros with arguments.

It is possible to control preprocessing itself with conditional statements that are evaluated during preprocessing. This provides a way to include code selectively, depending on the value of conditions evaluated during compilation.

The <span class="s4">#if </span>line evaluates a constant integer expression (which may not include <span class="s4">sizeof</span>, casts, or <span class="s4">enum </span>constants). If the expression is non-zero, subsequent lines until an <span class="s4">#endif </span>or <span class="s4">#elif </span>or <span class="s4">#else </span>are included. (The preprocessor statement <span class="s4">#elif </span>is like <span class="s4">else-if</span>.) The expression <span class="s4">defined</span>(_name_) in a <span class="s4">#if </span>is 1 if the _name _has been defined, and 0 otherwise.

For example, to make sure that the contents of a file <span class="s4">hdr.h </span>are included only once, the contents of the file are surrounded with a conditional like this:

#if !defined(HDR) #define HDR

/* contents of hdr.h go here */ #endif

The first inclusion of <span class="s4">hdr.h </span>defines the name <span class="s4">HDR</span>; subsequent inclusions will find the name defined and skip down to the <span class="s4">#endif</span>. A similar style can be used to avoid including files multiple times. If this style is used consistently, then each header can itself include any other headers on which it depends, without the user of the header having to deal with the interdependence.

This sequence tests the name <span class="s4">SYSTEM </span>to decide which version of a header to include:

#if SYSTEM == SYSV

#define HDR &quot;sysv.h&quot; #elif SYSTEM == BSD

#define HDR &quot;bsd.h&quot; #elif SYSTEM == MSDOS

#define HDR &quot;msdos.h&quot; #else

#define HDR &quot;default.h&quot; #endif

#include HDR

The <span class="s4">#ifdef </span>and <span class="s4">#ifndef </span>lines are specialized forms that test whether a name is defined. The first example of <span class="s4">#if </span>above could have been written

#ifndef HDR #define HDR

/* contents of hdr.h go here */ #endif

# Chapter 5 - Pointers and Arrays

A pointer is a variable that contains the address of a variable. Pointers are much used in C, partly because they are sometimes the only way to express a computation, and partly because they usually lead to more compact and efficient code than can be obtained in other ways. Pointers and arrays are closely related; this chapter also explores this relationship and shows how to exploit it.

Pointers have been lumped with the <span class="s4">goto </span>statement as a marvelous way to create impossible- to-understand programs. This is certainly true when they are used carelessly, and it is easy to create pointers that point somewhere unexpected. With discipline, however, pointers can also be used to achieve clarity and simplicity. This is the aspect that we will try to illustrate.

The main change in ANSI C is to make explicit the rules about how pointers can be manipulated, in effect mandating what good programmers already practice and good compilers already enforce. In addition, the type <span class="s4">void * </span>(pointer to <span class="s4">void</span>) replaces <span class="s4">char * </span>as the proper type for a generic pointer.

C is sometimes castigated for the syntax of its declarations, particularly ones that involve pointers to functions. The syntax is an attempt to make the declaration and the use agree; it works well for simple cases, but it can be confusing for the harder ones, because declarations cannot be read left to right, and because parentheses are over-used. The difference between

int *f(); /* f: function returning pointer to int */

and

int (*pf)(); /* pf: pointer to function returning int */

illustrates the problem: <span class="s4">* </span>is a prefix operator and it has lower precedence than <span class="s4">()</span>, so parentheses are necessary to force the proper association.

Although truly complicated declarations rarely arise in practice, it is important to know how to understand them, and, if necessary, how to create them. One good way to synthesize declarations is in small steps with <span class="s4">typedef</span>, which is discussed in <span class="s3">Section 6.7</span>. As an alternative, in this section we will present a pair of programs that convert from valid C to a word description and back again. The word description reads left to right.

The first, <span class="s4">dcl</span>, is the more complex. It converts a C declaration into a word description, as in these examples:

char **argv

argv: pointer to char int (*daytab)[13]

daytab: pointer to array[13] of int int *daytab[13]

daytab: array[13] of pointer to int void *comp()

comp: function returning pointer to void void (*comp)()

comp: pointer to function returning void char (*(*x())[])()

x: function returning pointer to array[] of pointer to function returning char

char (*(*x[3])())[5]

x: array[3] of pointer to function returning pointer to array[5] of char

<span class="s4">dcl </span>is based on the grammar that specifies a declarator, which is spelled out precisely in <span class="s3">Appendix A, Section 8.5</span>; this is a simplified form:

dcl: optional *&#39;s direct-dcl direct-dcl name

(dcl) direct-dcl()

direct-dcl[optional size]

In words, a _dcl _is a _direct-dcl_, perhaps preceded by *&#39;s. A _direct-dcl _is a name, or a parenthesized _dcl_, or a _direct-dcl _followed by parentheses, or a _direct-dcl _followed by brackets with an optional size.

This grammar can be used to parse functions. For instance, consider this declarator:

(*pfa[])()

<span class="s4">pfa </span>will be identified as a _name _and thus as a _direct-dcl_. Then <span class="s4">pfa[] </span>is also a _direct-dcl_. Then <span class="s4">*pfa[] </span>is recognized as a _dcl_, so <span class="s4">(*pfa[]) </span>is a _direct-dcl_. Then <span class="s4">(*pfa[])() </span>is a _direct-dcl _and thus a _dcl_. We can

<span>![image](The C Programming Language英文版 - 副本/Image_015.gif)</span>

The heart of the <span class="s4">dcl </span>program is a pair of functions, <span class="s4">dcl </span>and <span class="s4">dirdcl</span>, that parse a declaration according to this grammar. Because the grammar is recursively defined, the functions call each other recursively as they recognize pieces of a declaration; the program is called a recursive-descent parser.

/* dcl: parse a declarator */ void dcl(void)

{

int ns;

for (ns = 0; gettoken() == &#39;*&#39;; ) /* count *&#39;s */ ns++;

dirdcl();

while (ns-- &gt; 0)

strcat(out, &quot; pointer to&quot;);

}

/* dirdcl: parse a direct declarator */ void dirdcl(void)

{

int type;

if (tokentype == &#39;(&#39;) { /* ( dcl ) */ dcl();

if (tokentype != &#39;)&#39;) printf(&quot;error: missing )\n&quot;);

} else if (tokentype == NAME) /* variable name */ strcpy(name, token);

else

printf(&quot;error: expected name or (dcl)\n&quot;);

while ((type=gettoken()) == PARENS || type == BRACKETS)

if (type == PARENS)

strcat(out, &quot; function returning&quot;); else {

strcat(out, &quot; array&quot;); strcat(out, token); strcat(out, &quot; of&quot;);

}

}

Since the programs are intended to be illustrative, not bullet-proof, there are significant restrictions on <span class="s4">dcl</span>. It can only handle a simple data type line <span class="s4">char </span>or <span class="s4">int</span>. It does not handle argument types in functions, or qualifiers like <span class="s4">const</span>. Spurious blanks confuse it. It doesn&#39;t do much error recovery, so invalid declarations will also confuse it. These improvements are left as exercises.

Here are the global variables and the main routine:

#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt;

#define MAXTOKEN 100

enum { NAME, PARENS, BRACKETS };

void dcl(void); void dirdcl(void);

int gettoken(void);

int tokentype; /* type of last token */ char token[MAXTOKEN]; /* last token string */ char name[MAXTOKEN]; /* identifier name */

char datatype[MAXTOKEN]; /* data type = char, int, etc. */ char out[1000];

main() /* convert declaration to words */

{

while (gettoken() != EOF) { /* 1st token on line */ strcpy(datatype, token); /* is the datatype */ out[0] = &#39;\0&#39;;

dcl(); /* parse rest of line */ if (tokentype != &#39;\n&#39;)

printf(&quot;syntax error\n&quot;);

printf(&quot;%s: %s %s\n&quot;, name, out, datatype);

}

return 0;

}

The function <span class="s4">gettoken </span>skips blanks and tabs, then finds the next token in the input; a

``token&#39;&#39; is a name, a pair of parentheses, a pair of brackets perhaps including a number, or any other single character.

int gettoken(void) /* return next token */

{

int c, getch(void); void ungetch(int); char *p = token;

while ((c = getch()) == &#39; &#39; || c == &#39;\t&#39;)

;

if (c == &#39;(&#39;) {

if ((c = getch()) == &#39;)&#39;) {

strcpy(token, &quot;()&quot;); return tokentype = PARENS;

} else {

ungetch(c);

return tokentype = &#39;(&#39;;

}

} else if (c == &#39;[&#39;) {

for (*p++ = c; (*p++ = getch()) != &#39;]&#39;; )

;

*p = &#39;\0&#39;;

return tokentype = BRACKETS;

} else if (isalpha(c)) {

for (*p++ = c; isalnum(c = getch()); )

*p++ = c;

*p = &#39;\0&#39;; ungetch(c);

return tokentype = NAME;

} else

return tokentype = c;

}

<span class="s4">getch </span>and <span class="s4">ungetch </span>are discussed in <span class="s3">Chapter 4</span>.

Going in the other direction is easier, especially if we do not worry about generating redundant parentheses. The program <span class="s4">undcl </span>converts a word description like ``<span class="s4">x </span>is a function returning a pointer to an array of pointers to functions returning <span class="s4">char</span>,&#39;&#39; which we will express as

x () * [] * () char

to

char (*(*x())[])()

The abbreviated input syntax lets us reuse the <span class="s4">gettoken </span>function. <span class="s4">undcl </span>also uses the same external variables as <span class="s4">dcl </span>does.

/* undcl: convert word descriptions to declarations */ main()

{

int type;

char temp[MAXTOKEN];

while (gettoken() != EOF) { strcpy(out, token);

while ((type = gettoken()) != &#39;\n&#39;)

if (type == PARENS || type == BRACKETS) strcat(out, token);

else if (type == &#39;*&#39;) { sprintf(temp, &quot;(*%s)&quot;, out); strcpy(out, temp);

} else if (type == NAME) { sprintf(temp, &quot;%s %s&quot;, token, out); strcpy(out, temp);

} else

printf(&quot;invalid input at %s\n&quot;, token);

}

return 0;

}

**Exercise 5-18. **Make <span class="s4">dcl </span>recover from input errors.

**Exercise 5-19. **Modify <span class="s4">undcl </span>so that it does not add redundant parentheses to declarations.

**Exercise 5-20. **Expand <span class="s4">dcl </span>to handle declarations with function argument types, qualifiers like <span class="s4">const</span>, and so on.

# Chapter 6 - Structures

A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling. (Structures are called ``records&#39;&#39; in some languages, notably Pascal.) Structures help to organize complicated data, particularly in large programs, because they permit a group of related variables to be treated as a unit instead of as separate entities.

One traditional example of a structure is the payroll record: an employee is described by a set of attributes such as name, address, social security number, salary, etc. Some of these in turn could be structures: a name has several components, as does an address and even a salary. Another example, more typical for C, comes from graphics: a point is a pair of coordinate, a rectangle is a pair of points, and so on.

The main change made by the ANSI standard is to define structure assignment - structures may be copied and assigned to, passed to functions, and returned by functions. This has been supported by most compilers for many years, but the properties are now precisely defined. Automatic structures and arrays may now also be initialized.

When storage space is at a premium, it may be necessary to pack several objects into a single machine word; one common use is a set of single-bit flags in applications like compiler

symbol tables. Externally-imposed data formats, such as interfaces to hardware devices, also often require the ability to get at pieces of a word.

Imagine a fragment of a compiler that manipulates a symbol table. Each identifier in a program  has certain information associated  with it,  for example,  whether  or not  it is  a keyword, whether or not it is external and/or static, and so on. The most compact way to encode such information is a set of one-bit flags in a single <span class="s4">char </span>or <span class="s4">int</span>.

The usual way this is done is to define a set of ``masks&#39;&#39; corresponding to the relevant bit positions, as in

#define KEYWORD 01

#define EXTRENAL 02

#define STATIC 04

or

enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };

The numbers must be powers of two. Then accessing the bits becomes a matter of ``bit- fiddling&#39;&#39; with the shifting, masking, and complementing operators that were described in <span class="s3">Chapter 2</span>.

Certain idioms appear frequently:

flags |= EXTERNAL | STATIC;

turns on the <span class="s4">EXTERNAL </span>and <span class="s4">STATIC </span>bits in <span class="s4">flags</span>, while

flags &amp;= ~(EXTERNAL | STATIC);

turns them off, and

if ((flags &amp; (EXTERNAL | STATIC)) == 0) ...

is true if both bits are off.

Although these idioms are readily mastered, as an alternative C offers the capability of defining and accessing fields within a word directly rather than by bitwise logical operators. A _bit-field_, or _field _for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a ``word.&#39;&#39; For example, the symbol table <span class="s4">#define</span>s above could be replaced by the definition of three fields:

struct {

unsigned int is_keyword : 1; unsigned int is_extern : 1; unsigned int is_static : 1;

} flags;

This defines a variable table called <span class="s4">flags </span>that contains three 1-bit fields. The number following the colon represents the field width in bits. The fields are declared <span class="s4">unsigned int </span>to ensure that they are unsigned quantities.

Individual fields are referenced in the same way as other structure members: <span class="s4">flags.is_keyword</span>, <span class="s4">flags.is_extern</span>, etc. Fields behave like small integers, and may participate in arithmetic expressions just like other integers. Thus the previous examples may be written more naturally as

flags.is_extern = flags.is_static = 1;

to turn the bits on;

flags.is_extern = flags.is_static = 0;

to turn them off; and

if (flags.is_extern == 0 &amp;&amp; flags.is_static == 0)

...

to test them.

Almost everything about fields is implementation-dependent. Whether a field may overlap a word boundary is implementation-defined. Fields need not be names; unnamed fields (a colon and width only) are used for padding. The special width 0 may be used to force alignment at the next word boundary.

Fields are assigned left to right on some machines and right to left on others. This means that although fields are useful for maintaining internally-defined data structures, the question of which end comes first has to be carefully considered when picking apart externally-defined data; programs that depend on such things are not portable. Fields may be declared only as <span class="s4">int</span>s; for portability, specify <span class="s4">signed </span>or <span class="s4">unsigned </span>explicitly. They are not arrays and they do not have addresses, so the <span class="s4">&amp; </span>operator cannot be applied on them.

# Chapter 7 - Input and Output

Input and output are not part of the C language itself, so we have not emphasized them in our presentation thus far. Nonetheless, programs interact with their environment in much more complicated ways than those we have shown before. In this chapter we will describe the standard library, a set of functions that provide input and output, string handling, storage management, mathematical routines, and a variety of other services for C programs. We will concentrate on input and output

The ANSI standard defines these library functions precisely, so that they can exist in compatible form on any system where C exists. Programs that confine their system interactions to facilities provided by the standard library can be moved from one system to another without change.

The properties of library functions are specified in more than a dozen headers; we have already seen several of these, including <span class="s4">&lt;stdio.h&gt;</span>, <span class="s4">&lt;string.h&gt;</span>, and <span class="s4">&lt;ctype.h&gt;</span>. We will not present the entire library here, since we are more interested in writing C programs that use it. The library is described in detail in <span class="s3">Appendix B</span>.

A conversion specification directs the conversion of the next input field. Normally the result is places in the variable pointed to by the corresponding argument. If assignment suppression is indicated by the * character, however, the input field is skipped; no assignment is made. An input field is defined as a string of non-white space characters; it extends either to the next white space character or until the field width, is specified, is exhausted. This implies that <span class="s4">scanf </span>will read across boundaries to find its input, since newlines are white space. (White space characters are blank, tab, newline, carriage return, vertical tab, and formfeed.)

The conversion character indicates the interpretation of the input field. The corresponding argument must be a pointer, as required by the call-by-value semantics of C. Conversion characters are shown in Table 7.2.

Table 7.2: <span class="s2">Basic Scanf Conversions</span>

<table style="border-collapse:collapse;margin-left:8.34012pt" cellspacing="0"><tr style="height:29pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

Characte r
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

Input Data; Argument type
</td></tr><tr style="height:16pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

d
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

decimal integer; <span class="s8">int *</span>
</td></tr><tr style="height:29pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

i
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

integer; <span class="s8">int *</span>. The integer may be in octal (leading <span class="s8">0</span>) or hexadecimal (leading

0x <span class="s9">or </span>0X<span class="s9">).</span>
</td></tr><tr style="height:16pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

o
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

octal integer (with or without leading zero); <span class="s8">int *</span>
</td></tr><tr style="height:16pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

u
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

unsigned decimal integer; <span class="s8">unsigned int *</span>
</td></tr><tr style="height:16pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

x
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

hexadecimal integer (with or without leading <span class="s8">0x </span>or <span class="s8">0X</span>); <span class="s8">int *</span>
</td></tr><tr style="height:42pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

c
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

characters; <span class="s8">char *</span>. The next input characters (default 1) are placed at the

indicated spot. The normal skip-over white space is suppressed; to read the next non-white space character, use <span class="s8">%1s</span>
</td></tr><tr style="height:29pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

s
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

character string (not quoted); <span class="s8">char *</span>, pointing to an array of characters long enough for the string and a terminating <span class="s8">&#39;\0&#39; </span>that will be added.
</td></tr><tr style="height:29pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

e,f,g
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

floating-point number with optional sign, optional decimal point and optional exponent; <span class="s8">float *</span>
</td></tr><tr style="height:16pt"><td style="width:57pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

%
</td><td style="width:395pt;border-top-style:solid;border-top-width:1pt;border-top-color:#7E7E7E;border-left-style:solid;border-left-width:1pt;border-left-color:#7E7E7E;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#7E7E7E;border-right-style:solid;border-right-width:1pt;border-right-color:#7E7E7E">

literal %; no assignment is made.
</td></tr></table>

The conversion characters <span class="s4">d</span>, <span class="s4">i</span>, <span class="s4">o</span>, <span class="s4">u</span>, and <span class="s4">x </span>may be preceded by <span class="s4">h </span>to indicate that a pointer to <span class="s4">short </span>rather than <span class="s4">int </span>appears in the argument list, or by <span class="s4">l </span>(letter ell) to indicate that a pointer to <span class="s4">long </span>appears in the argument list.

As a first example, the rudimentary calculator of <span class="s3">Chapter 4</span> can be written with <span class="s4">scanf </span>to do the input conversion:

#include &lt;stdio.h&gt;

main() /* rudimentary calculator */

{

double sum, v;

sum = 0;

while (scanf(&quot;%lf&quot;, &amp;v) == 1) printf(&quot;\t%.2f\n&quot;, sum += v);

return 0;

}

Suppose we want to read input lines that contain dates of the form

25 Dec 1988

The <span class="s4">scanf </span>statement is

int day, year; char monthname[20];

scanf(&quot;%d %s %d&quot;, &amp;day, monthname, &amp;year);

No <span class="s4">&amp; </span>is used with <span class="s4">monthname</span>, since an array name is a pointer.

Literal characters can appear in the <span class="s4">scanf </span>format string; they must match the same characters in the input. So we could read dates of the form <span class="s4">mm/dd/yy </span>with the <span class="s4">scanf </span>statement:

int day, month, year; scanf(&quot;%d/%d/%d&quot;, &amp;month, &amp;day, &amp;year);

scanf <span class="p">ignores blanks and tabs in its format string. Furthermore, it skips over white space (blanks, tabs, newlines, etc.) as it looks for input values. To read input whose format is not fixed, it is often best to read a line at a time, then pick it apart with </span>scanf<span class="p">. For example, suppose we want to read lines that might contain a date in either of the forms above. Then we could write</span>

while (getline(line, sizeof(line)) &gt; 0) {

if (sscanf(line, &quot;%d %s %d&quot;, &amp;day, monthname, &amp;year) == 3) printf(&quot;valid: %s\n&quot;, line); /* 25 Dec 1988 form */

else if (sscanf(line, &quot;%d/%d/%d&quot;, &amp;month, &amp;day, &amp;year) == 3) printf(&quot;valid: %s\n&quot;, line); /* mm/dd/yy form */

else

printf(&quot;invalid: %s\n&quot;, line); /* invalid form */

}

Calls to <span class="s4">scanf </span>can be mixed with calls to other input functions. The next call to any input function will begin by reading the first character not read by <span class="s4">scanf</span>.

A final warning: the arguments to <span class="s4">scanf </span>and <span class="s4">sscanf </span>_must _be pointers. By far the most common error is writing

scanf(&quot;%d&quot;, n);

instead of

scanf(&quot;%d&quot;, &amp;n);

This error is not generally detected at compile time.

**Exercise 7-4. **Write a private version of <span class="s4">scanf </span>analogous to <span class="s4">minprintf </span>from the previous section.

**Exercise 5-5. **Rewrite the postfix calculator of <span class="s3">Chapter 4</span> to use <span class="s4">scanf </span>and/or <span class="s4">sscanf </span>to do the input and number conversion.

The function <span class="s4">rand() </span>computes a sequence of pseudo-random integers in the range zero to <span class="s4">RAND_MAX</span>, which is defined in <span class="s4">&lt;stdlib.h&gt;</span>. One way to produce random floating-point numbers greater than or equal to zero but less than one is

#define frand() ((double) rand() / (RAND_MAX+1.0))

(If your library already provides a function for floating-point random numbers, it is likely to have better statistical properties than this one.)

The function <span class="s4">srand(unsigned) </span>sets the seed for <span class="s4">rand</span>. The portable implementation of <span class="s4">rand</span>

and <span class="s4">srand </span>suggested by the standard appears in <span class="s3">Section 2.7</span>.

**Exercise 7-9. **Functions like <span class="s4">isupper </span>can be implemented to save space or to save time. Explore both possibilities.

# Chapter 8 - The UNIX System Interface

The UNIX operating system provides its services through a set of _system calls_, which are in effect functions within the operating system that may be called by user programs. This chapter describes how to use some of the most important system calls from C programs. If you use UNIX, this should be directly helpful, for it is sometimes necessary to employ system calls for maximum efficiency, or to access some facility that is not in the library. Even if you use C on a different operating system, however, you should be able to glean insight into C programming from studying these examples; although details vary, similar code will be found on any system. Since the ANSI C library is in many cases modeled on UNIX facilities, this code may help your understanding of the library as well.

This chapter is divided into three major parts: input/output, file system, and storage allocation. The first two parts assume a modest familiarity with the external characteristics of UNIX systems.

Chapter 7<span class="s5"> </span><span class="p">was concerned with an input/output interface that is uniform across operating systems. On any particular system the routines of the standard library have to be written in terms of the facilities provided by the host system. In the next few sections we will describe the UNIX system calls for input and output, and show how parts of the standard library can be implemented with them.</span>

In <span class="s3">Chapter 5</span>, we presented a vary limited stack-oriented storage allocator. The version that we will now write is unrestricted. Calls to <span class="s4">malloc </span>and <span class="s4">free </span>may occur in any order; <span class="s4">malloc </span>calls upon the operating system to obtain more memory as necessary. These routines illustrate some of the considerations involved in writing machine-dependent code in a relatively machine-independent way, and also show a real-life application of structures, unions and <span class="s4">typedef</span>.

Rather than allocating from a compiled-in fixed-size array, <span class="s4">malloc </span>will request space from the operating system as needed. Since other activities in the program may also request space without calling this allocator, the space that <span class="s4">malloc </span>manages may not be contiguous. Thus its free storage is kept as a list of free blocks. Each block contains a size, a pointer to the next block, and the space itself. The blocks are kept in order of increasing storage address, and the last block (highest address) points to the first.

<span>![image](The C Programming Language英文版 - 副本/Image_020.gif)</span>

When a request is made, the free list is scanned until a big-enough block is found. This algorithm is called ``first fit,&#39;&#39; by contrast with ``best fit,&#39;&#39; which looks for the smallest block that will satisfy the request. If the block is exactly the size requested it is unlinked from the list and returned to the user. If the block is too big, it is split, and the proper amount is returned to the user while the residue remains on the free list. If no big-enough block is found, another large chunk is obtained by the operating system and linked into the free list.

Freeing also causes a search of the free list, to find the proper place to insert the block being freed. If the block being freed is adjacent to a free block on either side, it is coalesced with it into a single bigger block, so storage does not become too fragmented. Determining the adjacency is easy because the free list is maintained in order of decreasing address.

One problem, which we alluded to in <span class="s3">Chapter 5</span>, is to ensure that the storage returned by <span class="s4">malloc </span>is aligned properly for the objects that will be stored in it. Although machines vary, for each machine there is a most restrictive type: if the most restrictive type can be stored at a particular address, all other types may be also. On some machines, the most restrictive type is a <span class="s4">double</span>; on others, <span class="s4">int </span>or <span class="s4">long </span>suffices.

A free block contains a pointer to the next block in the chain, a record of the size of the block, and then the free space itself; the control information at the beginning is called the ``header.&#39;&#39; To simplify alignment, all blocks are multiples of the header size, and the header is aligned properly. This is achieved by a union that contains the desired header structure and an instance of the most restrictive alignment type, which we have arbitrarily made a <span class="s4">long</span>:

typedef long Align; /* for alignment to long boundary */ union header { /* block header */

struct {

union header *ptr; /* next block if on free list */ unsigned size; /* size of this block */

} s;

Align x; /* force alignment of blocks */

};

typedef union header Header;

The <span class="s4">Align </span>field is never used; it just forces each header to be aligned on a worst-case boundary.

In <span class="s4">malloc</span>, the requested size in characters is rounded up to the proper number of header- sized units; the block that will be allocated contains one more unit, for the header itself, and this is the value recorded in the <span class="s4">size </span>field of the header. The pointer returned by <span class="s4">malloc </span>points at the free space, not at the header itself. The user can do anything with the space requested, but if anything is written outside of the allocated space the list is likely to be scrambled.

<span>![image](The C Programming Language英文版 - 副本/Image_021.gif)</span>

The size field is necessary because the blocks controlled by <span class="s4">malloc </span>need not be contiguous - it is not possible to compute sizes by pointer arithmetic.

The variable <span class="s4">base </span>is used to get started. If <span class="s4">freep </span>is <span class="s4">NULL</span>, as it is at the first call of <span class="s4">malloc</span>, then a degenerate free list is created; it contains one block of size zero, and points to itself. In any case, the free list is then searched. The search for a free block of adequate size begins at the point (<span class="s4">freep</span>) where the last block was found; this strategy helps keep the list homogeneous. If a too-big block is found, the tail end is returned to the user; in this way the header of the original needs only to have its size adjusted. In all cases, the pointer returned to the user points to the free space within the block, which begins one unit beyond the header.

static Header base; /* empty list to get started */ static Header *freep = NULL; /* start of free list */

/* malloc: general-purpose storage allocator */ void *malloc(unsigned nbytes)

{

Header *p, *prevp;

Header *moreroce(unsigned); unsigned nunits;

nunits = (nbytes+sizeof(Header)-1)/sizeof(header) + 1; if ((prevp = freep) == NULL) { /* no free list yet */

base.s.ptr = freeptr = prevptr = &amp;base; base.s.size = 0;

}

for (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) { if (p-&gt;s.size &gt;= nunits) { /* big enough */

if (p-&gt;s.size == nunits) /* exactly */ prevp-&gt;s.ptr = p-&gt;s.ptr;

else { /* allocate tail end */ p-&gt;s.size -= nunits;

p += p-&gt;s.size;

p-&gt;s.size = nunits;

}

freep = prevp; return (void *)(p+1);

}

if (p == freep) /* wrapped around free list */ if ((p = morecore(nunits)) == NULL)

return NULL; /* none left */

}

}

The function <span class="s4">morecore </span>obtains storage from the operating system. The details of how it does this vary from system to system. Since asking the system for memory is a comparatively expensive operation. we don&#39;t want to do that on every call to <span class="s4">malloc</span>, so <span class="s4">morecore </span>requests al least <span class="s4">NALLOC </span>units; this larger block will be chopped up as needed. After setting the size field, <span class="s4">morecore </span>inserts the additional memory into the arena by calling <span class="s4">free</span>.

The UNIX system call <span class="s4">sbrk(n) </span>returns a pointer to <span class="s4">n </span>more bytes of storage. <span class="s4">sbrk </span>returns <span class="s4">-1 </span>if there was no space, even though <span class="s4">NULL </span>could have been a better design. The <span class="s4">-1 </span>must be cast to <span class="s4">char * </span>so it can be compared with the return value. Again, casts make the function relatively immune to the details of pointer representation on different machines. There is still one assumption, however, that pointers to different blocks returned by <span class="s4">sbrk </span>can be meaningfully compared. This is not guaranteed by the standard, which permits pointer comparisons only within an array. Thus this version of <span class="s4">malloc </span>is portable only among machines for which general pointer comparison is meaningful.

#define NALLOC 1024 /* minimum #units to request */

/* morecore: ask system for more memory */ static Header *morecore(unsigned nu)

{

char *cp, *sbrk(int); Header *up;

if (nu &lt; NALLOC) nu = NALLOC;

cp = sbrk(nu * sizeof(Header));

if (cp == (char *) -1) /* no space at all */ return NULL;

up = (Header *) cp; up-&gt;s.size = nu; free((void *)(up+1)); return freep;

}

free <span class="p">itself is the last thing. It scans the free list, starting at </span>freep<span class="p">, looking for the place to insert the free block. This is either between two existing blocks or at the end of the list. In any case, if the block being freed is adjacent to either neighbor, the adjacent blocks are combined. The only troubles are keeping the pointers pointing to the right things and the sizes correct.</span>

/* free: put block ap in free list */ void free(void *ap)

{

Header *bp, *p;

bp = (Header *)ap - 1; /* point to block header */ for (p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)

if (p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr)) break; /* freed block at start or end of arena */

if (bp + bp-&gt;size == p-&gt;s.ptr) { /* join to upper nbr */ bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;

bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;

} else

bp-&gt;s.ptr = p-&gt;s.ptr;

if (p + p-&gt;size == bp) { /* join to lower nbr */ p-&gt;s.size += bp-&gt;s.size;

p-&gt;s.ptr = bp-&gt;s.ptr;

} else

p-&gt;s.ptr = bp; freep = p;

}

Although storage allocation is intrinsically machine-dependent, the code above illustrates how the machine dependencies can be controlled and confined to a very small part of the program. The use of <span class="s4">typedef </span>and <span class="s4">union </span>handles alignment (given that <span class="s4">sbrk </span>supplies an appropriate pointer). Casts arrange that pointer conversions are made explicit, and even cope with a badly-designed system interface. Even though the details here are related to storage allocation, the general approach is applicable to other situations as well.

**Exercise 8-6. **The standard library function <span class="s4">calloc(n,size) </span>returns a pointer to <span class="s4">n </span>objects of size <span class="s4">size</span>, with the storage initialized to zero. Write <span class="s4">calloc</span>, by calling <span class="s4">malloc </span>or by modifying it.

<span class="h4">Exercise 8-7. </span>malloc <span class="p">accepts a size request without checking its plausibility; </span>free <span class="p">believes that the block it is asked to free contains a valid size field. Improve these routines so they make more pains with error checking.</span>

**Exercise 8-8. **Write a routine <span class="s4">bfree(p,n) </span>that will free any arbitrary block <span class="s4">p </span>of <span class="s4">n </span>characters into the free list maintained by <span class="s4">malloc </span>and <span class="s4">free</span>. By using <span class="s4">bfree</span>, a user can add a static or external array to the free list at any time.

# Appendix A - Reference Manual

Below is a recapitulation of the grammar that was given throughout the earlier part of this appendix. It has exactly the same content, but is in different order.

The grammar has undefined terminal symbols _integer-constant_, _character-constant_, _floating- constant_, _identifier_, _string_, and _enumeration-constant_; the <span class="s4">typewriter </span>style words and symbols are terminals given literally. This grammar can be transformed mechanically into input acceptable for an automatic parser-generator. Besides adding whatever syntactic marking is used to indicate alternatives in productions, it is necessary to expand the ``one of&#39;&#39; constructions, and (depending on the rules of the parser-generator) to duplicate each production with an _opt _symbol, once with the symbol and once without. With one further change, namely deleting the production _typedef-name_: _identifier _and making _typedef-name _a terminal symbol, this grammar is acceptable to the YACC parser-generator. It has only one conflict, generated by the <span class="s4">if-else </span>ambiguity.

translation-unit<span class="p">:</span>

external-declaration

translation-unit external-declaration

external-declaration<span class="p">:</span>

function-definition declaration

function-definition<span class="p">:</span>

declaration-specifiers<span class="s12">opt </span>declarator declaration-list<span class="s12">opt </span>compound-statement

declaration<span class="p">:</span>

declaration-specifiers init-declarator-list<span class="s12">opt</span><span class="s15">;</span>

declaration-list<span class="p">:</span>

declaration

declaration-list declaration

declaration-specifiers<span class="p">:</span>

storage-class-specifier declaration-specifiers<span class="s12">opt </span>type-specifier declaration-specifiers<span class="s12">opt</span>

type-qualifier declaration-specifiers<span class="s19">opt</span>

storage-class specifier<span class="p">: one of</span>

auto register static extern typedef

type specifier<span class="p">: one of</span>

void char short int long float double signed unsigned <span class="s2">struct-or-union-specifier enum-specifier typedef-name</span>

type-qualifier<span class="p">: one of</span>

const volatile

struct-or-union-specifier<span class="p">:</span>

struct-or-union identifier<span class="s12">opt </span><span class="s15">{ </span><span class="s2">struct-declaration-list </span><span class="s4">}</span>

struct-or-union identifier

struct-or-union<span class="p">: one of</span>

struct union

struct-declaration-list<span class="p">:</span>

struct declaration

struct-declaration-list struct declaration

init-declarator-list<span class="p">:</span>

init-declarator

init-declarator-list<span class="s4">, </span>init-declarator

init-declarator<span class="p">:</span>

declarator

declarator <span class="s4">= </span>initializer

struct-declaration<span class="p">:</span>

specifier-qualifier-list struct-declarator-list<span class="s4">;</span>

specifier-qualifier-list<span class="p">:</span>

type-specifier specifier-qualifier-list<span class="s19">opt </span><span class="s11">type-qualifier specifier-qualifier-list</span><span class="s12">opt</span>

struct-declarator-list<span class="p">:</span>

struct-declarator

struct-declarator-list <span class="s4">, </span>struct-declarator

struct-declarator<span class="p">: </span>declarator

declarator<span class="s12">opt </span><span class="s15">:</span><span class="s4"> </span><span class="s2">constant-expression</span>

enum-specifier<span class="p">:</span>

<span class="s15">enum</span> <span class="s2">identifier</span><span class="s12">opt </span><span class="s15">{</span> <span class="s2">enumerator-list </span>} enum <span class="s2">identifier</span>

enumerator-list<span class="p">:</span>

enumerator

enumerator-list <span class="s4">, </span>enumerator

enumerator<span class="p">:</span>

identifier

identifier <span class="s4">= </span>constant-expression

declarator<span class="p">:</span>

pointer<span class="s12">opt </span>direct-declarator

direct-declarator<span class="p">:</span>

identifier

(<span class="s2">declarator</span>)

<span class="s11">direct-declarator </span><span class="s4">[ </span>constant-expression<span class="s12">opt </span><span class="s15">] </span>direct-declarator <span class="s4">( </span>parameter-type-list <span class="s4">) </span>direct-declarator <span class="s4">( </span>identifier-list<span class="s19">opt </span><span class="s4">)</span>

pointer<span class="p">:</span>

*   type-qualifier-list<span class="s12">opt</span>

*   type-qualifier-list<span class="s12">opt </span>pointer

type-qualifier-list<span class="p">:</span>

type-qualifier

type-qualifier-list type-qualifier

parameter-type-list<span class="p">:</span>

parameter-list parameter-list <span class="s4">, ...</span>

parameter-list<span class="p">:</span>

parameter-declaration

parameter-list <span class="s4">, </span>parameter-declaration

parameter-declaration<span class="p">: </span>declaration-specifiers declarator

declaration-specifiers abstract-declarator<span class="s19">opt</span>

identifier-list<span class="p">:</span>

identifier

identifier-list <span class="s4">, </span>identifier

initializer<span class="p">:</span>

assignment-expression

{ <span class="s2">initializer-list </span>}

{ <span class="s2">initializer-list </span>, }

initializer-list<span class="p">:</span>

initializer

initializer-list <span class="s4">, </span>initializer

type-name<span class="p">:</span>

specifier-qualifier-list abstract-declarator<span class="s19">opt</span>

abstract-declarator<span class="p">:</span>

pointer

pointer<span class="s12">opt </span>direct-abstract-declarator

direct-abstract-declarator<span class="p">:</span>

( _abstract-declarator _)

<span class="s11">direct-abstract-declarator</span>opt <span class="s13">[</span><span class="s2">constant-expression</span>opt<span class="s13">]</span>

direct-abstract-declarator<span class="s19">opt</span><span class="s12"> </span><span class="p">(</span>parameter-type-list<span class="s19">opt</span><span class="p">)</span>

typedef-name<span class="p">:</span>

identifier

statement<span class="p">:</span>

labeled-statement expression-statement compound-statement selection-statement iteration-statement jump-statement

labeled-statement<span class="p">:</span>

identifier <span class="s4">: </span>statement

case <span class="s2">constant-expression </span>: <span class="s2">statement</span>

default : <span class="s2">statement</span>

expression-statement<span class="p">:</span>

expression<span class="s12">opt</span><span class="s15">;</span>

compound-statement<span class="p">:</span>

<span class="s4">{ </span>declaration-list<span class="s19">opt </span>statement-list<span class="s19">opt </span><span class="s4">}</span>

statement-list<span class="p">:</span>

statement

statement-list statement

selection-statement<span class="p">:</span>

<span class="s4">if </span>(_expression_) _statement_

<span class="s4">if </span><span class="p">(</span>expression<span class="p">) </span>statement <span class="s4">else </span>statement

<span class="s4">switch </span>(_expression_) _statement_

iteration-statement<span class="p">:</span>

<span class="s4">while </span>(_expression_) _statement_

do <span class="s2">statement </span>while <span class="p">(</span><span class="s2">expression</span><span class="p">)</span>;

<span class="s15">for</span><span class="s4"> </span><span class="p">(</span>expression<span class="s12">opt</span><span class="s15">;</span><span class="s4"> </span>expression<span class="s12">opt</span><span class="s15">;</span><span class="s4"> </span>expression<span class="s12">opt</span><span class="s13">) </span>statement

jump-statement<span class="p">:</span>

goto <span class="s2">identifier</span>; continue; break;

return <span class="s2">expression</span><span class="s19">opt</span>;

expression<span class="p">:</span>

assignment-expression

expression <span class="s4">, </span>assignment-expression

assignment-expression<span class="p">:</span>

conditional-expression

unary-expression assignment-operator assignment-expression

assignment-operator<span class="p">: one of</span>

= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=

conditional-expression<span class="p">:</span>

logical-OR-expression

logical-OR-expression <span class="s4">? </span>expression <span class="s4">: </span>conditional-expression

constant-expression<span class="p">:</span>

conditional-expression

logical-OR-expression<span class="p">:</span>

logical-AND-expression

logical-OR-expression <span class="s4">|| </span>logical-AND-expression

logical-AND-expression<span class="p">:</span>

inclusive-OR-expression

logical-AND-expression <span class="s4">&amp;&amp; </span>inclusive-OR-expression

inclusive-OR-expression<span class="p">:</span>

exclusive-OR-expression

inclusive-OR-expression <span class="s4">| </span>exclusive-OR-expression

exclusive-OR-expression<span class="p">:</span>

AND-expression

exclusive-OR-expression <span class="s4">^ </span>AND-expression

AND-expression<span class="p">:</span>

equality-expression

AND-expression <span class="s4">&amp; </span>equality-expression

equality-expression<span class="p">:</span>

relational-expression

equality-expression <span class="s4">== </span>relational-expression equality-expression <span class="s4">!= </span>relational-expression

relational-expression<span class="p">:</span>

shift-expression

relational-expression <span class="s4">&lt; </span>shift-expression relational-expression <span class="s4">&gt; </span>shift-expression relational-expression <span class="s4">&lt;= </span>shift-expression relational-expression <span class="s4">&gt;= </span>shift-expression

shift-expression<span class="p">:</span>

additive-expression

shift-expression <span class="s4">&lt;&lt; </span>additive-expression shift-expression <span class="s4">&gt;&gt; </span>additive-expression

additive-expression<span class="p">:</span>

multiplicative-expression

additive-expression <span class="s4">+ </span>multiplicative-expression additive-expression <span class="s4">- </span>multiplicative-expression

multiplicative-expression<span class="p">:</span>

multiplicative-expression <span class="s4">* </span>cast-expression multiplicative-expression <span class="s4">/ </span>cast-expression multiplicative-expression <span class="s4">% </span>cast-expression

cast-expression<span class="p">:</span>

unary expression

(_type-name_) _cast-expression_

unary-expression<span class="p">:</span>

postfix expression

++<span class="s2">unary expression</span>

--<span class="s2">unary expression</span>

unary-operator cast-expression <span class="s4">sizeof </span>unary-expression <span class="s4">sizeof </span><span class="p">(</span>type-name<span class="p">)</span>

unary operator<span class="p">: one of</span>

&amp; * + - ~ !

postfix-expression<span class="p">:</span>

primary-expression

postfix-expression<span class="p">[</span>expression<span class="p">]</span>

<span class="s11">postfix-expression</span><span class="p">(</span>argument-expression-list<span class="s12">opt</span><span class="s13">) </span>postfix-expression<span class="p">.</span>identifier

postfix-expression<span class="s4">-&gt;</span><span class="p">+</span>identifier postfix-expression<span class="s4">++</span>

postfix-expression<span class="s4">--</span>

primary-expression<span class="p">:</span>

identifier constant string <span class="p">(</span>expression<span class="p">)</span>

argument-expression-list<span class="p">:</span>

assignment-expression

assignment-expression-list <span class="s4">, </span>assignment-expression

constant<span class="p">:</span>

integer-constant character-constant floating-constant enumeration-constant

The following grammar for the preprocessor summarizes the structure of control lines, but is not suitable for mechanized parsing. It includes the symbol _text_, which means ordinary program text, non-conditional preprocessor control lines, or complete preprocessor conditional instructions.

control-line<span class="p">:</span>

# define <span class="s2">identifier token-sequence</span>

<span class="s4"># define </span>identifier<span class="p">(</span>identifier, ... , identifier<span class="p">) </span>token-sequence

# undef <span class="s2">identifier</span>

# include &lt;<span class="s2">filename</span>&gt; # include &quot;<span class="s2">filename</span>&quot;

# line <span class="s2">constant </span>&quot;<span class="s2">filename</span>&quot; # line <span class="s2">constant</span>

# error<span class="s4"> </span><span class="s2">token-sequence</span><span class="s12">opt</span>

# pragma<span class="s4"> </span><span class="s2">token-sequence</span><span class="s12">opt</span>

#

preprocessor-conditional

preprocessor-conditional<span class="p">:</span>

if-line text elif-parts else-part<span class="s12">opt </span><span class="s15">#endif</span>

if-line<span class="p">:</span>

# if <span class="s2">constant-expression</span>

# ifdef <span class="s2">identifier</span>

# ifndef <span class="s2">identifier</span>

elif-parts<span class="p">:</span>

elif-line text elif-parts<span class="s19">opt</span>

elif-line<span class="p">:</span>

# elif <span class="s2">constant-expression</span>

else-part<span class="p">: </span>else-line text

else-line<span class="p">:</span>

#else

# Appendix B - Standard Library

This appendix is a summary of the library defined by the ANSI standard. The standard library is not part of the C language proper, but an environment that supports standard C will provide the function declarations and type and macro definitions of this library. We have omitted a few functions that are of limited utility or easily synthesized from others; we have omitted multi-byte characters; and we have omitted discussion of locale issues; that is, properties that depend on local language, nationality, or culture.

The functions, types and macros of the standard library are declared in standard _headers_:

&lt;assert.h&gt; &lt;float.h&gt; &lt;math.h&gt; &lt;stdarg.h&gt; &lt;stdlib.h&gt;

&lt;ctype.h&gt; &lt;limits.h&gt; &lt;setjmp.h&gt; &lt;stddef.h&gt; &lt;string.h&gt;

&lt;errno.h&gt; &lt;locale.h&gt; &lt;signal.h&gt; &lt;stdio.h&gt; &lt;time.h&gt;

A header can be accessed by

<span class="s4">#include </span>&lt;_header_&gt;

Headers may be included in any order and any number of times. A header must be included outside of any external declaration or definition and before any use of anything it declares. A header need not be a source file.

External identifiers that begin with an underscore are reserved for use by the library, as are all other identifiers that begin with an underscore and an upper-case letter or another underscore.

&lt;limits.h&gt; and &lt;float.h&gt;

The header &lt;limits.h&gt; defines constants for the sizes of integral types. The values below are acceptable minimum magnitudes; larger values may be used.

CHAR_BIT 8 bits in a char

CHAR_MAX <span class="s4">UCHAR_MAX </span>_or_

SCHAR_MAX

maximum value of char

<span class="s15">CHAR_MIN </span>0 <span class="s2">or </span>SCHAR_MIN <span class="p">maximum value of </span>char <span class="s15">INT_MAX 32767 </span><span class="p">maximum value of </span>int

INT_MIN -32767 <span class="p">minimum value of </span><span class="s4">int</span>

LONG_MAX 2147483647 <span class="s28">maximum value of</span><span class="p"> </span>long

LONG_MIN -2147483647 <span class="s28">minimum value of</span><span class="p"> </span>long

SCHAR_MAX +127 <span class="p">maximum value of </span><span class="s4">signed char</span>

SCHAR_MIN -127 <span class="p">minimum value of </span><span class="s4">signed char</span>

SHRT_MAX +32767 <span class="p">maximum value of </span><span class="s4">short</span>

SHRT_MIN -32767 <span class="p">minimum value of </span><span class="s4">short</span>

UCHAR_MAX 255 <span class="p">maximum value of </span><span class="s4">unsigned char</span>

UINT_MAX 65535 <span class="p">maximum value of </span><span class="s4">unsigned int</span>

ULONG_MAX 4294967295 <span class="p">maximum value of </span><span class="s4">unsigned long</span>

USHRT_MAX 65535 <span class="s4">maximum value of unsigned short</span>

The names in the table below, a subset of &lt;float.h&gt;, are constants related to floating-point arithmetic. When a value is given, it represents the minimum magnitude for the corresponding quantity. Each implementation defines appropriate values.

FLT_RADIX 2 <span class="p">radix of exponent, representation, e.g., 2, 16 </span>FLT_ROUNDS <span class="p">floating-point rounding mode for addition </span>FLT_DIG 6 <span class="p">decimal digits of precision</span>

<span class="s15">FLT_EPSILON 1E-5 </span>smallest number _x _such that 1.0+x != 1.0 <span class="s15">FLT_MANT_DIG </span>number of base <span class="s4">FLT_RADIX </span>in mantissa <span class="s15">FLT_MAX 1E+37</span><span class="s4"> </span>maximum floating-point number

<span class="s15">FLT_MAX_EXP </span>maximum _n _such that <span class="s4">FLT_RADIX</span><span class="s22">n-1 </span>is representable <span class="s15">FLT_MIN 1E-37 </span>minimum normalized floating-point number <span class="s15">FLT_MIN_EXP </span>minimum _n _such that 10<span class="s14">n </span>is a normalized number <span class="s15">DBL_DIG 10 </span>decimal digits of precision

<span class="s15">DBL_EPSILON 1E-9 </span>smallest number _x _such that 1.0+x != 1.0 <span class="s15">DBL_MANT_DIG </span>number of base <span class="s4">FLT_RADIX </span>in mantissa <span class="s15">DBL_MAX 1E+37 </span>maximum <span class="s4">double </span>floating-point number

<span class="s15">DBL_MAX_EXP </span>maximum _n _such that <span class="s4">FLT_RADIX</span><span class="s22">n-1 </span>is representable <span class="s15">DBL_MIN 1E-37 </span>minimum normalized <span class="s4">double </span>floating-point number <span class="s15">DBL_MIN_EXP </span>minimum _n _such that 10<span class="s14">n </span>is a normalized number

# Appendix C - Summary of Changes

Since the publication of the first edition of this book, the definition of the C language has undergone changes. Almost all were extensions of the original language, and were carefully designed to remain compatible with existing practice; some repaired ambiguities in the original description; and some represent modifications that change existing practice. Many of the new facilities were announced in the documents accompanying compilers available from AT&amp;T, and have subsequently been adopted by other suppliers of C compilers. More recently, the ANSI committee standardizing the language incorporated most of the changes, and also introduced other significant modifications. Their report was in part participated by some commercial compilers even before issuance of the formal C standard.

This Appendix summarizes the differences between the language defined by the first edition of this book, and that expected to be defined by the final standard. It treats only the language itself, not its environment and library; although these are an important part of the standard, there is little to compare with, because the first edition did not attempt to prescribe an environment or library.

*   Preprocessing is more carefully defined in the Standard than in the first edition, and is extended: it is explicitly token based; there are new operators for concatenation of tokens (<span class="s4">##</span>), and creation of strings (<span class="s4">#</span>); there are new control lines like <span class="s4">#elif </span>and <span class="s4">#pragma</span>; redeclaration of macros by the same token sequence is explicitly permitted; parameters inside strings are no longer replaced. Splicing of lines by \ is permitted everywhere, not just in strings and macro definitions. See <span class="s3">Par.A.12</span>.

*   The minimum significance of all internal identifiers increased to 31 characters; the smallest mandated significance of identifiers with external linkage remains 6 monocase letters. (Many implementations provide more.)

*   Trigraph sequences introduced by <span class="s4">?? </span>allow representation of characters lacking in some character sets. Escapes for <span class="s4">#\^[]{}|~ </span>are defined, see <span class="s3">Par.A.12.1</span>. Observe that the introduction of trigraphs may change the meaning of strings containing the sequence <span class="s4">??</span>.

*   New keywords (<span class="s4">void, const, volatile, signed, enum</span>) are introduced. The stillborn <span class="s4">entry </span>keyword is withdrawn.

*   New escape sequences, for use within character constants and string literals, are defined. The effect of following \ by a character not part of an approved escape sequence is undefined. See <span class="s3">Par.A.2.5.2</span>.

*   Everyone&#39;s favorite trivial change: <span class="s4">8 </span>and <span class="s4">9 </span>are not octal digits.

*   The standard introduces a larger set of suffixes to make the type of constants explicit: <span class="s4">U </span>or <span class="s4">L </span>for integers, <span class="s4">F </span>or <span class="s4">L </span>for floating. It also refines the rules for the type of unsiffixed constants (<span class="s3">Par.A.2.5</span>).

*   Adjacent string literals are concatenated.

*   There is a notation for wide-character string literals and character constants; see<span class="s3"> Par.A.2.6</span>.

*   Characters as well as other types, may be explicitly declared to carry, or not to carry, a sign by using the keywords <span class="s4">signed </span>or <span class="s4">unsigned</span>. The locution <span class="s4">long float </span>as a synonym for <span class="s4">double </span>is withdrawn, but <span class="s4">long double </span>may be used to declare an extra- precision floating quantity.

*   For some time, type <span class="s4">unsigned char </span>has been available. The standard introduces the

signed <span class="p">keyword to make signedness explicit for </span>char <span class="p">and other integral objects.</span>

*   The <span class="s4">void </span>type has been  available  in most implementations for some  years. The Standard introduces the use of the <span class="s4">void * </span>type as a generic pointer type; previously <span class="s4">char * </span>played this role. At the same time, explicit rules are enacted against mixing pointers and integers, and pointers of different type, without the use of casts.

*   The Standard places explicit minima on the ranges of the arithmetic types, and mandates headers (<span class="s4">&lt;limits.h&gt; </span>and <span class="s4">&lt;float.h&gt;</span>) giving the characteristics of each particular implementation.

*   Enumerations are new since the first edition of this book.

*   The Standard adopts from C++ the notion of type qualifier, for example <span class="s4">const</span>

(<span class="s3">Par.A.8.2</span>).

*   Strings are no longer modifiable, and so may be placed in read-only memory.

*   The ``usual arithmetic conversions&#39;&#39; are changed, essentially from ``for integers, <span class="s4">unsigned </span>always wins; for floating point, always use <span class="s4">double</span>&#39;&#39; to ``promote to the smallest capacious-enough type.&#39;&#39; See <span class="s3">Par.A.6.5</span>.

*   The old assignment operators like <span class="s4">=+ </span>are truly gone. Also, assignment operators are now single tokens; in the first edition, they were pairs, and could be separated by white space.

*   A compiler&#39;s license to treat mathematically associative operators as computationally associative is revoked.

*   A unary <span class="s4">+ </span>operator is introduced for symmetry with unary <span class="s4">-</span>.

*   A pointer to a function may be used as a function designator without an explicit <span class="s4">*</span>

operator. See <span class="s3">Par.A.7.3.2</span>.

*   Structures may be assigned, passed to functions, and returned by functions.

*   Applying the address-of operator to arrays is permitted, and the result is a pointer to the array.

*   The <span class="s4">sizeof </span>operator, in the first edition, yielded type <span class="s4">int</span>; subsequently, many implementations made it <span class="s4">unsigned</span>. The Standard makes its type explicitly implementation-dependent, but requires the type, <span class="s4">size_t</span>, to be defined in a standard header (<span class="s4">&lt;stddef.h&gt;</span>). A similar change occurs in the type (<span class="s4">ptrdiff_t</span>) of the difference between pointers. See <span class="s3">Par.A.7.4.8</span> and <span class="s3">Par.A.7.7</span>.

*   The address-of operator <span class="s4">&amp; </span>may not be applied to an object declared <span class="s4">register</span>, even if the implementation chooses not to keep the object in a register.

*   The type of a shift expression is that of the left operand; the right operand can&#39;t promote the result. See <span class="s3">Par.A.7.8</span>.

*   The Standard legalizes the creation of a pointer just beyond the end of an array, and allows arithmetic and relations on it; see <span class="s3">Par.A.7.7</span>.

*   The Standard introduces (borrowing from C++) the notion of a function prototype declaration that incorporates the types of the parameters, and includes an explicit

recognition of variadic functions together with an approved way of dealing with them. See Pars. <span class="s3">A.7.3.2</span>, <span class="s3">A.8.6.3</span>, <span class="s3">B.7</span>. The older style is still accepted, with restrictions.

*   Empty declarations, which have no declarators and don&#39;t declare at least a structure, union, or enumeration, are forbidden by the Standard. On the other hand, a declaration with just a structure or union tag redeclares that tag even if it was declared in an outer scope.

*   External data declarations without any specifiers or qualifiers (just a naked declarator) are forbidden.

*   Some implementations, when presented with an <span class="s4">extern </span>declaration in an inner block, would export the declaration to the rest of the file. The Standard makes it clear that the scope of such a declaration is just the block.

*   The scope of parameters is injected into a function&#39;s compound statement, so that variable declarations at the top level of the function cannot hide the parameters.

*   The name spaces of identifiers are somewhat different. The Standard puts all tags in a single name space, and also introduces a separate name space for labels; see<span class="s3"> Par.A.11.1</span>. Also, member names are associated with the structure or union of which they are a part. (This has been common practice from some time.)

*   Unions may be initialized; the initializer refers to the first member.

*   Automatic structures, unions, and arrays may be initialized, albeit in a restricted way.

*   Character arrays with an explicit size may be initialized by a string literal with exactly that many characters (the <span class="s4">\0 </span>is quietly squeezed out).

*   The controlling expression, and the case labels, of a switch may have any integral type.</body></html>